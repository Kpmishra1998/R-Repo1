<!DOCTYPE html>
<html>
  <head>
    <title>Inference</title>
    <meta charset="utf-8">
    <meta name="author" content="Edward Rubin" />
    <meta name="date" content="2019-05-24" />
    <link href="08RInference_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="08RInference_files/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="08RInference_files/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="my-css.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Inference
## EC 425/525, Lab 8
### Edward Rubin
### 24 May 2019

---

class: inverse, middle



# Prologue

---
name: schedule

# Schedule

## Last time

Helpful tips and tricks in .mono[R]

## Today

Inference (in .mono[R])
---
layout: true
# Inference

---
class: inverse, middle
---
name: motive
## Motivation

So far, we've focused on carefully .hi[obtaining causal estimates] of the effect of some treatment `\(\text{D}_{i}\)` on our outcome `\(\text{Y}_{i}\)`.

--

Our discussion of research designs and their requirements/assumptions has centered on .hi[avoiding selection and securing unbiased and/or consistent estimates] for `\(\tau\)`.

--

In other words, we've concentrated on .hi[point estimates].

What about .hi-purple[inference]?
---
## Shminference

.qa[Q] Why care about inference?

--

.qa[A] I'll give you two reasons.

--

1. We often want to .hi[test theories/hypotheses]. Point estimates (*i.e.*, `\(\hat{\beta}\)`) can't do this alone. Inference finishes the job.

--

2. Other times, we want to .hi[*measure* the effect] of a treatment. Inference helps us think about the .hi[precision] of our estimates.

--

.note[Note:] Similar reasoning can apply to bounding forecasting/predictions.

--

If you want answers, then you need to do inference
--
 correctly.
---
## What's so complicated?

Angrist and Pischke told us that "correcting" our standard errors for heteroskedasticity may increase the standard errors up to 25%.

What else are we worried about?

---
## What we're worried about

- .hi-slate[Transformations of estimators], *i.e.*, `\(\mathop{\text{Var}} \left[ f\left(\hat\beta\right) \right] \neq f\!\left(\mathop{\text{Var}} \left[ \hat\beta \right]\right)\)`

--

- .hi-slate[Dependence/correlation in our disturbance], *i.e.*, `\(\mathop{\text{Cov}} \left(\varepsilon_i,\,\varepsilon_j \right)\neq 0\)`
  - .slate[Autocorrelation] `\(\varepsilon_t = \rho \varepsilon_{t-1} + \varepsilon_t\)`
  - .slate[Correlated shocks within groups] `\(\varepsilon_i = \varepsilon_{g(i)} + \varepsilon_i\)`

--

- .hi-slate[Finite-sample properties] *vs.* asymptotic properties

--

- .hi-slate[Power] and .hi-slate[minimal detectable effects]

--

- .hi-slate[Multiple-hypothesis testing] and .hi-slate[*p-hacking*]

--

.it[In other words:] We've got a lot to worry/think about.
---
layout: true
# Clustering

---
name: clustering
class: inverse, middle
---
## Setup

Many studies—observational and experimental—have a treatment that is assigned to all/most individuals within a group.
- Classrooms/schools
- Households
- Villages/counties/states

--

Furthermore, we might imagine individuals within the same group may have correlated disturbances. For `\(i\)` and `\(j\)` in group `\(g\)`
$$
`\begin{align}
  \mathop{\text{Cov}} \left( \varepsilon_{i},\, \varepsilon_{j} \right) = \mathop{E}\left[ \varepsilon_{i} \varepsilon_{j} \right] = \rho_\varepsilon \sigma^2_\varepsilon
\end{align}`
$$
where `\(\rho_\varepsilon\)` gives the within-group correlation of disturbances—what *MHE* calls the .attn[intraclass correlation coefficient].
---
## Setup

In other words, we have a regression
$$
`\begin{align}
  y_{i} = \beta_0 + \beta_1 x_{g(i)} + \varepsilon_i
\end{align}`
$$
where individual `\(i\)` is in group `\(g\)`, and `\(\text{X}_{g(i)}\)` only varies across groups.

--

For within-group correlation, we can use an additive random-effects model
$$
`\begin{align}
  \varepsilon_i = \nu_{g(i)} + \eta_i
\end{align}`
$$
meaning group members all receive a common shock `\(\nu_{g(i)}\)`, and individuals receive independent shocks `\(\eta_i\)`.

--

.note[Note] We assume `\(\eta_i\)` is independent of `\(\eta_j\)` `\(\left( i\neq j \right)\)` and `\(\nu_g\)` `\(\left( \forall g \right)\)`.
---
## Additive random effects

Based upon this model we've set up
$$
`\begin{align}
  \varepsilon_i = \nu_{g(i)} + \eta_i
\end{align}`
$$
the covariance between individuals `\(i\)` and `\(j\)` in group `\(g\)` is
$$
`\begin{align}
  \mathop{\text{Cov}} \left( \varepsilon_i,\, \varepsilon_j \right) &amp;= \mathop{E}\left[ \varepsilon_i \varepsilon_j \right] = \mathop{E}\left[ \left( \nu_g + \eta_i \right) \left( \nu_g + \eta_j \right) \right] = \mathop{E}\left[ \nu_g^2 \right] = \sigma^2_\nu
  \\ &amp;= \rho_\varepsilon\sigma^2_\varepsilon
  \\ &amp;= \rho_\varepsilon \left( \sigma^2_\nu + \sigma^2_\eta \right)
\end{align}`
$$

Thus, we can write the intraclass correlation coefficient as
$$
`\begin{align}
  \rho_\varepsilon = \dfrac{\sigma^2_\nu}{\sigma^2_\varepsilon} = \dfrac{\sigma^2_\nu}{\sigma^2_\nu + \sigma^2_\eta}
\end{align}`
$$
---
## What is `\(\rho_\varepsilon?\)`

Let's review what we know.
$$
`\begin{align}
  \varepsilon_i = \nu_{g(i)} + \eta_i \quad\quad \color{#6A5ACD}{\text{and}} \quad\quad \rho_\varepsilon = \dfrac{\sigma^2_\nu}{\sigma^2_\varepsilon} = \dfrac{\sigma^2_\nu}{\sigma^2_\nu + \sigma^2_\eta}
\end{align}`
$$

--

One way to think about `\(\rho_\varepsilon\)` is as the .hi[share of the variance of the disturbance] `\(\varepsilon_i\)` .hi[accounted for by the shared disurbance] `\(\nu_{g(i)}\)`.

--

As `\(\nu_{g(i)}\)` accounts for more and more of the variation in `\(\varepsilon_i\)`, `\(\rho_\varepsilon\rightarrow 1\)`.

---
## So...

.qa[Q] Why do we care about `\(\rho_\varepsilon\)`?

--

.qa[A] It tells us by how wrong our standard errors can be if we treat all observations as independent.

--

Let `\(\mathop{\text{Var}_o} \left( \hat\beta_1 \right)\)` denote the conventional variance formula for OLS estimator..super[.pink[†]]
.footnote[
.pink[†] which treats all disturbances as independent (and identically distributed).
]

--

Let `\(\mathop{\text{Var}} \left( \hat\beta_1 \right)\)` denote the actual variance of `\(\hat\beta_1\)`.

---
name: moulton
## So....

With (.hi-slate[1]) nonstochasic regressors fixed by group *and* (.hi-slate[2]) groups of size `\(n\)`

`\(\quad\dfrac{\mathop{\text{Var}} \left( \hat\beta_1 \right)}{\mathop{\text{Var}_o} \left( \hat\beta_1 \right)} = 1 + (n-1) \rho_\varepsilon\quad\)`
--
`\(\implies \quad \dfrac{\mathop{\text{S.E.}} \left( \hat\beta_1 \right)}{\mathop{\text{S.E.}_o} \left( \hat\beta_1 \right)} = \sqrt{1 + (n-1) \rho_\varepsilon}\)`

--

The term `\(\sqrt{1 + (n-1) \rho_\varepsilon}\)` is called the .attn[Moulton factor].super[.pink[†]].

The .attn[Moulton factor] tells us by what factor standard errors will be wrong if we ignore within-group correlation (conditional on assumptions .hi-slate[1] and .hi-slate[2]).

.footnote[
.pink[†] After [Moulton (1986)](https://www.sciencedirect.com/science/article/pii/0304407686900217).
]

--

.qa[Q] What happens if `\(\rho =\)` 1?
--
 What if you duplicated your dataset?
--
&lt;br&gt;.qa[Q] What happens as `\(n\)` increases?

---
name: moulton-example
## The Moulton factor

The Moulton factor
$$
`\begin{align}
  \dfrac{\mathop{\text{S.E.}} \left( \hat\beta_1 \right)}{\mathop{\text{S.E.}_o} \left( \hat\beta_1 \right)} = \sqrt{1 + (n-1) \rho_\varepsilon}
\end{align}`
$$
shows even when `\(\rho_\varepsilon\)` is small, we can have vary large standard error issues.

--

.ex[Ex] An experiment on 400 schools, each with 1,000 students.

--

If `\(\rho_\varepsilon = 0.01\)`, the Moulton factor is `\(\sqrt{1 + (1,000-1)\times0.01}\approx 3.32\)`.

---
name: moulton-tstat
## Test statistics

.note[Recall] `\(t_\text{stat} = \dfrac{\hat{\beta}_1}{\mathop{\text{S.E.}} \left( \hat\beta_1 \right)}\)`.

--

`\(\therefore \dfrac{t_o}{t}\)`
--
 `\(= \dfrac{\hat{\beta}_1/\mathop{\text{S.E.}_o} \left( \hat\beta_1 \right)}{\hat{\beta}_1/\mathop{\text{S.E.}} \left( \hat\beta_1 \right)}\)`
--
 `\(=\dfrac{\mathop{\text{S.E.}} \left( \hat\beta_1 \right)}{\mathop{\text{S.E.}_o} \left( \hat\beta_1 \right)}\)`
--
 `\(=\)` the Moulton factor.

--

.ex[Ex] Thus, in our example of 400 schools with 1,000 students, ignoring within-school correlation of `\(\rho_\varepsilon=\)` 0.01 would lead us test statistics that are more than 3 times as large as they should be.

--

This is why economics seminars have standard-error police.
---
## Relaxing assumptions

If we allow regressors to vary by individual and groups to differ in size `\(\left( n_g \right)\)`,
$$
`\begin{align}
  \dfrac{\mathop{\text{Var}} \left( \hat\beta_1 \right)}{\mathop{\text{Var}_o} \left( \hat\beta_1 \right)} =
  1 + \left[ \dfrac{\mathop{\text{Var}} \left( n_g \right)}{\overline{n}} + \overline{n} - 1 \right]\rho_x \rho_\varepsilon
\end{align}`
$$
where `\(\rho_x\)` denotes the intraclass (within-group) correlation of `\(x_i\)`..super[.pink[†]]

.footnote[
.pink[†] See *MHE* for mathematical definitions and the derivation.
]

--

.attn[Important] The Moulton factor for this general model depends upon the amount of within-group correlation in `\(x_i\)` *and* `\(\varepsilon_i\)`.

--

The special case is also important, as treatment is often fixed at some level.
---
name: cluster_answers
## The answer

.qa[Q] So what do we do now?

--

.qa[A] We've got options (as usual)

1. Parametrically model the random effects
2. Cluster-robust standard error (estimator)
3. Aggregate up to the group (or a similar method)
4. Block (group-based) bootstrap
5. GLS/MLE modeling `\(y_i\)` and `\(\varepsilon_i\)`

--

.hi-orange[Most common:] Cluster-robust standard errors
&lt;br&gt; .hi-red[Runner up:] Block bootstrap
&lt;br&gt; .hi-pink[Second runner up:] Group-level analysis

---
name: cluster-robust
## Cluster-robust standard errors

[Liang and Zeger (1986)](https://doi.org/10.1093/biomet/73.1.13) extend White's heteroskedasticity-robust covariance matrix to allow for both clustering and heteroskedasticity..super[.pink[†]]

.footnote[
.pink[†] When people say *clustering*, they typically mean *correlated disturbances within a group.*
]

--

.smaller[
$$
`\begin{align}
  \hat{\Omega}_\text{cl} = \left( \text{X}^\prime \text{X} \right)^{-1} \left( \sum_g \text{X}_g' \hat{\Psi}_g \text{X}_g \right) \left( \text{X}^\prime \text{X} \right)^{-1}
\end{align}`
$$
$$
`\begin{align}
  \hat{\Psi}_g = a e_g e_g' = a
  \begin{bmatrix}
    e_{1g}^2 &amp; e_{1g} e_{2g} &amp; \cdots &amp; e_{1g} e_{n_g g} \\
    e_{1g} e_{2g} &amp; e_{2g}^2 &amp; e_{2g} \cdots &amp; e_{2g} e_{n_g g} \\
    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    e_{1g} e_{n_g g} &amp; e_{2g} e_{n_g g} &amp; \cdots &amp; e_{n_g g}^2
  \end{bmatrix}
\end{align}`
$$
]

such that `\(e_{g}\)` are the OLS residuals for group `\(g\)`, `\(e_{ig}\)` is the residual for individual `\(i\)` in group `\(g\)`, and `\(a\)` is a degrees-of-freedom adjustment.

---
## Cluster-robust standard errors

So now you know what `lm_robust()`, `iv_robust()`, *etc.* are doing when you specify a variable for clustering (*e.g.*, `clusters = var`).

--

Time for a simulation.

---
layout: true
# Cluster simulation

---
name: cluser-sim
class: inverse, middle
---
## The DGP

Let's opt for a simple-ish example..super[.pink[†]]

.footnote[
.pink[†] So we have more room for problem sets.
]

$$
`\begin{align}
  y_{ig} &amp;= 1 + 2 x_{g} + \varepsilon_{ig} \\
  \varepsilon_{ig} &amp;= \nu_g + \eta_i
\end{align}`
$$
where the `\(\eta_i\perp\eta_j\)`, `\(\eta_i\perp\nu_g\)`, and `\(\nu_g\perp\nu_h\)`.

--

Let's assume `\(\eta_i\sim N(0,1)\)` and `\(\nu_g\sim N(0,1)\)`. And `\(x_g\sim N(0,1)\)`.

Plus `\(n = 100\)` with 10 groups.

---
layout: true
class: clear
---

First we need to write the data generating process for one iteration.



```r
# The DGP
sim_dgp &lt;- function(n = 100, n_grps = 10, σν = 1, ση = 1) {
  # Create the right number of observations
  sample_df &lt;- expand.grid(i = 1:n, g = 1:n_grps) %&gt;% as_tibble()
  # Create a unique ID (from 1 to number of observations)
  sample_df %&lt;&gt;% mutate(id = 1:(n * n_grps))
  # Sample ν at the group level
  # NOTE: Ungroup after grouping
  sample_df %&lt;&gt;% group_by(g) %&gt;%
    mutate(ν = rnorm(1, sd = σν)) %&gt;% ungroup()
  # Sample η at the individual level
  sample_df %&lt;&gt;% mutate(η = rnorm(n * n_grps, sd = ση))
  # Sample x_g from N(0,1)
  sample_df %&lt;&gt;% group_by(g) %&gt;% mutate(x = rnorm(1)) %&gt;% ungroup()
  # Calculate y
  sample_df %&lt;&gt;% mutate(y = 1 + 2 * x + ν + η)
  # Return
  return(sample_df)
}
```
---

Now we analyze.

```r
# Analyze 'data'
sim_analyze &lt;- function(data) {
  # Conventional SEs
  se_ols &lt;- lm_robust(y ~ x, data = data, se_type = "classical") %&gt;%
    tidy() %&gt;% extract2(2,3)
  # Cluster-robust SEs
  se_cl &lt;- lm_robust(y ~ x, data = data, clusters = g) %&gt;%
    tidy() %&gt;% extract2(2,3)
  # Return a data frame of results
  data.frame(
    se = c(se_ols, se_cl),
    type = c("conventional", "clustered")
  )
}
```
---

Now put them together with another function.

```r
# Join sim_dgp and sim_analyze
sim_iter &lt;- function(n = 100, n_grps = 10, σν = 1, ση = 1) {
  # Run the analysis in sim_analyze on the output of sim_dgp
  sim_dgp(n = 100, n_grps = 10, σν = 1, ση = 1) %&gt;% sim_analyze()
}
```

---

And we run the simulation.

```r
# Load and set up 'furrr'
p_load(furrr)
plan(multiprocess, workers = 8)
# Set a seed
set.seed(1234)
# Run the simulation 1,000 times
sim_df &lt;- future_map_dfr(
  # Repeat sample size 100 for 1000 times
  rep(100, 1000),
  # Our function
  sim_iter,
  # Let furrr know we want to set a seed
  .options = future_options(seed = T)
)
```

---

&lt;img src="08RInference_files/figure-html/plot-sim-1.svg" style="display: block; margin: auto;" /&gt;




---
layout: false
# Table of contents

.pull-left[
### Inference
.small[
1. [Motivation](#motive)
1. [Clustering](#clustering)
1. [Moulton factors](#moulton)
  - [Example](#moulton-example)
  - [Test statistics](#moulton-tstats)
1. [Answers](#cluster-answers)
1. [Cluster-robust S.E.s](#cluster-robust)
1. [Simulation](#simulation)
]]

---
exclude: true
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
